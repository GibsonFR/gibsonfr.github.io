<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Player</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
</head>
<body class="bg-slate-950 text-slate-100">
  <div class="max-w-5xl mx-auto p-4">
    <a href="index.html" class="text-indigo-400 hover:underline">&larr; Back</a>
    <header id="header" class="mt-2 mb-6"></header>

    <section class="mb-8">
      <h2 class="text-xl font-semibold mb-2">Elo Timeline</h2>
      <div class="rounded border border-slate-800 p-3">
        <canvas id="eloChart" height="140"></canvas>
      </div>
    </section>

    <section>
      <h2 class="text-xl font-semibold mb-2">Recent matches</h2>
      <div id="matches" class="space-y-2"></div>
    </section>
  </div>

<script>
const SUPA_URL  = "https://yykwhpeczfapkileuxtb.supabase.co";
const SUPA_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl5a3docGVjemZhcGtpbGV1eHRiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIwMjM4NzUsImV4cCI6MjA3NzU5OTg3NX0.Sz2G1DG0CVYC9WSuYSODnH9k0_ybVluZAtRGBwb55wo";
const supa = supabase.createClient(SUPA_URL, SUPA_ANON);

const url = new URL(location.href);
let steamId = url.searchParams.get('steam_id');
const q = url.searchParams.get('q');

const esc = s => (s||'').replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
const fmt = iso => {
  try {
    const d = new Date(iso);
    const pad = n => String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  } catch { return iso || ''; }
};

async function resolveQuery(){
  if(steamId) return steamId;
  if(!q) return null;
  const { data } = await supa.rpc('search_players',{ q, p_limit:1 });
  if(data && data.length) return data[0].steam_id;
  return null;
}

function renderHeader(p){
  return `<div class="p-4 rounded border border-slate-800">
    <div class="text-2xl font-bold">${esc(p.username||p.steam_id)}</div>
    <div class="text-slate-300">
      Rank: <span class="text-slate-100">${esc(p.rank||'')}</span> ·
      Elo: <span class="text-slate-100">${p.elo??'-'}</span> ·
      RP: <span class="text-slate-100">${p.rp??'-'}</span> ·
      Games: ${p.games??0} · Win%: ${p.win_rate??0}
    </div>
  </div>`;
}

function drawElo(labels, values){
  const ctx = document.getElementById('eloChart').getContext('2d');
  new Chart(ctx,{
    type:'line',
    data:{ labels, datasets:[{ label:'Elo', data: values, tension:0.25, pointRadius:0, borderWidth:2, fill:false }]},
    options:{
      plugins:{ legend:{ labels:{ color:'#cbd5e1' } }, tooltip:{ callbacks:{
        // Pas de timestamp dans le label : on ne montre que Elo
        title: () => '',
        label: (ctx)=> ` Elo: ${ctx.parsed.y}`
      }}},
      scales:{
        x:{ display:false, grid:{ display:false } },   // <-- aucune étiquette/timestamp
        y:{ ticks:{ color:'#94a3b8' }, grid:{ color:'rgba(148,163,184,0.15)' } }
      }
    }
  });
}

async function load(){
  steamId = await resolveQuery();
  if(!steamId){ document.getElementById('header').innerHTML='<div class="text-red-400">Player not found.</div>'; return; }

  const { data: player } = await supa.from('players').select('*').eq('steam_id',steamId).single();
  if(!player){ document.getElementById('header').innerHTML='<div class="text-red-400">Player not found.</div>'; return; }
  document.getElementById('header').innerHTML = renderHeader(player);

  // Timeline depuis ratings (fallback matches si vide)
  let { data: rt } = await supa.from('ratings')
    .select('at, elo_before, elo_after')
    .eq('player_id', steamId)
    .order('at', { ascending: true });

  if(!rt || rt.length < 2){
    const { data: mm } = await supa.from('matches')
      .select('played_at,p1_id,p2_id,p1_elo_before,p1_elo_after,p2_elo_before,p2_elo_after')
      .or(`p1_id.eq.${steamId},p2_id.eq.${steamId}`)
      .order('played_at',{ascending:true})
      .limit(2000);
    rt = (mm||[]).map(m=>{
      const meIsP1 = m.p1_id===steamId;
      return { at: m.played_at,
               elo_before: meIsP1 ? m.p1_elo_before : m.p2_elo_before,
               elo_after:  meIsP1 ? m.p1_elo_after  : m.p2_elo_after };
    });
  }

  const labels = rt.map((_,i)=> i+1); // index uniquement, pas de dates
  const values = rt.map(x=> (x.elo_after ?? x.elo_before ?? null));
  drawElo(labels, values);

  // Historique des matchs (liste claire, UNE seule zone cliquable par match)
  const { data: matches } = await supa.from('matches')
    .select('id,played_at,p1_id,p2_id,p1_name,p2_name,winner,map_id,p1_elo_after,p2_elo_after,p1_elo_before,p2_elo_before')
    .or(`p1_id.eq.${steamId},p2_id.eq.${steamId}`)
    .order('played_at',{ascending:false})
    .limit(50);

  const cont = document.getElementById('matches'); cont.innerHTML='';
  for(const m of (matches||[])){
    const meIsP1 = m.p1_id===steamId;
    const oppNm  = meIsP1 ? (m.p2_name||'Opponent') : (m.p1_name||'Opponent');
    const res    = m.winner==='1' ? (meIsP1 ? 'W' : 'L') : (m.winner==='2' ? (meIsP1 ? 'L' : 'W') : '—');
    const meElo  = meIsP1 ? (m.p1_elo_after ?? m.p1_elo_before ?? '-') : (m.p2_elo_after ?? m.p2_elo_before ?? '-');

    cont.innerHTML += `
      <a href="match.html?id=${m.id}" class="block p-3 rounded border border-slate-800 hover:border-indigo-500">
        <div class="text-slate-300 text-sm">${fmt(m.played_at)}</div>
        <div class="font-semibold">vs ${esc(oppNm)}</div>
        <div class="text-slate-400 text-sm">Result: <span class="text-slate-100">${res}</span> · Map ${m.map_id ?? '-' } · Elo ${meElo}</div>
      </a>`;
  }
}
load();
</script>
</body>
</html>
