<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Perspective</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    .reveal{opacity:0;transform:translateY(8px);transition:opacity .5s ease,transform .5s ease}
    .reveal.show{opacity:1;transform:translateY(0)}
    .pulse-once{animation:pulseOnce .6s ease-out 1}
    @keyframes pulseOnce{0%{transform:scale(1)}40%{transform:scale(1.03)}100%{transform:scale(1)}}
    .bar{transition:width .6s ease}
    .tip{position:relative;cursor:help}
    .tip:after{
      content:attr(data-tip);
      position:absolute;left:50%;transform:translateX(-50%) translateY(8px);
      background:#0f172a;color:#e2e8f0;border:1px solid #334155;
      padding:.45rem .6rem;border-radius:.5rem;font-size:.75rem;line-height:1rem;
      white-space:pre-wrap;width:280px;max-width:80vw;pointer-events:none;
      opacity:0;transition:opacity .15s ease,transform .15s ease;z-index:20
    }
    .tip:hover:after{opacity:1;transform:translateX(-50%) translateY(6px)}
    /* Mirror compare rows: force each row to align left vs right */
    .mirror-row{display:grid;grid-template-columns:1fr;gap:1rem}
    @media (min-width: 768px){.mirror-row{grid-template-columns:1fr 1fr}}
    .card{border:1px solid rgb(30 41 59);background:rgba(15,23,42,.4);border-radius:1rem;padding:1rem}
    .pill{border-radius:9999px;border:1px solid rgb(51 65 85);background:rgba(30,41,59,.6);color:#e5e7eb}
    .pill-active{background:rgba(245,158,11,.2);color:#fbbf24;border-color:rgba(245,158,11,.3)}
  </style>
</head>
<body class="bg-slate-950 text-slate-100">
  <div class="max-w-6xl mx-auto p-4">
    <div id="authbar" class="mb-3"></div>
  </div>

  <div class="max-w-6xl mx-auto p-4">
    <a href="index.html" class="text-indigo-400 hover:underline">&larr; Back</a>

    <header id="head" class="mt-3"></header>

    <!-- MAP FILTERS -->
    <div id="scopeBar" class="mt-4 hidden"></div>

    <!-- EXTRA FILTERS (ELO bands) -->
    <div id="filterBar" class="mt-3 hidden"></div>

    <!-- PREMIUM / AUTH GATE -->
    <div id="gateBanner" class="mt-4 p-4 rounded-2xl border border-slate-800 bg-slate-900/60 hidden"></div>

    <!-- Actions -->
    <div class="mt-4 grid grid-cols-1 lg:grid-cols-[1fr_1fr] gap-3">
      <div class="card">
        <div class="flex flex-wrap items-center gap-3">
          <button id="queueBtn" class="px-3 py-2 rounded-xl bg-amber-600 hover:bg-amber-500 border border-amber-400/30 disabled:opacity-50">
            Build Perspective (send to worker)
          </button>
          <button id="refreshBtn" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-500 border border-indigo-400/30 disabled:opacity-50">
            Recompute metrics (local)
          </button>
          <span id="status" class="text-sm text-slate-400"></span>
        </div>
        <div id="jobInfo" class="mt-2 text-xs text-slate-400"></div>
      </div>

      <div class="card">
        <form id="cmpForm" class="flex flex-wrap items-center gap-2" onsubmit="return false;">
          <label class="text-slate-300">Compare vs</label>
          <input id="cmpInput" class="flex-1 bg-slate-800 border border-slate-700 rounded px-2 py-1 text-sm" placeholder="username or SteamID64â€¦">
          <button id="cmpBtn" class="px-3 py-2 rounded-xl bg-amber-600 hover:bg-amber-500 border border-amber-400/30 disabled:opacity-50">
            Compare (mirror)
          </button>
          <label class="ml-2 text-xs text-slate-400 flex items-center gap-2" title="Apply the current map/Elo filters to the comparison">
            <input id="cmpUseFilter" type="checkbox" class="accent-amber-500">
            Apply current filters
          </label>
          <span id="cmpStatus" class="text-sm text-slate-400"></span>
        </form>
      </div>
    </div>

    <!-- CONTENT -->
    <div id="content" class="mt-6"></div>
  </div>

<script>
/* -------------------- Supabase -------------------- */
const SUPA_URL  = "https://yykwhpeczfapkileuxtb.supabase.co";
const SUPA_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl5a3docGVjemZhcGtpbGV1eHRiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIwMjM4NzUsImV4cCI6MjA3NzU5OTg3NX0.Sz2G1DG0CVYC9WSuYSODnH9k0_ybVluZAtRGBwb55wo";
const supa = supabase.createClient(SUPA_URL, SUPA_ANON);

const url = new URL(location.href);
const steamId = url.searchParams.get('steam_id');
const WINDOW_ALL = 0;

/* Map names */
const MAP_NAMES = {35:'Mini Monke',36:'Small Beach',38:'Small Containers',39:'Tiny Town 2',40:'Tiny Town'};
const prettyMap = id => MAP_NAMES[id] ? `${id} â€” ${MAP_NAMES[id]}` : `Map ${id}`;

/* -------------------- Utils -------------------- */
const esc = s => (s||'').replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
const pct = x => (x==null||isNaN(x) ? 'â€”' : `${Math.round(x*1000)/10}%`);
const num = (x,d=1)=> (x==null||isNaN(x) ? 'â€”' : (Math.round(x*Math.pow(10,d))/Math.pow(10,d)));
const fmtS = s => (s==null||isNaN(s)?'â€”':`${num(s,1)}s`);
function median(a){ a=(a||[]).filter(Number.isFinite).sort((x,y)=>x-y); if(!a.length) return null; const m=a.length/2; return a.length%2? a[(m|0)] : (a[m-1]+a[m])/2; }
function quantile(arr,q){ const a=(arr||[]).filter(Number.isFinite).sort((x,y)=>x-y); if(!a.length) return null; const pos=(a.length-1)*q, lo=Math.floor(pos), hi=Math.ceil(pos); return lo===hi ? a[lo] : a[lo]+(a[hi]-a[lo])*(pos-lo); }
function p90(a){ return quantile(a,.90); }
function p10(a){ return quantile(a,.10); }
function sum(a){ return (a||[]).reduce((t,x)=>t+(Number.isFinite(x)?x:0),0); }
function avg(a){ a=(a||[]).filter(Number.isFinite); return a.length? sum(a)/a.length : null; }
function std(a){ a=(a||[]).filter(Number.isFinite); if(!a.length) return null; const m=avg(a); return Math.sqrt(avg(a.map(x=>(x-m)*(x-m)))); }
function lastN(a,n){ return (a||[]).slice(Math.max(0,a.length-n)); }
function clamp01(x){ return Math.max(0, Math.min(1, Number(x)||0)); }

/* SVG sparkline */
function spark(values, w=240, h=48){
  values=(values||[]).filter(Number.isFinite); if(!values.length) return `<svg width="${w}" height="${h}"></svg>`;
  const min=Math.min(...values), max=Math.max(...values);
  const norm=v=>(max===min)? .5 : (v-min)/(max-min);
  const pts = values.map((v,i)=>[i*(w-6)/Math.max(1,values.length-1)+3, h-6 - norm(v)*(h-12) + 3]);
  const d = 'M '+pts.map(p=>p.join(' ')).join(' L ');
  return `<svg width="${w}" height="${h}" class="text-amber-300"><path d="${d}" fill="none" stroke="currentColor" stroke-width="2"/></svg>`;
}

/* Bars */
function bar(v01, title=''){
  const w = (clamp01(v01)*100).toFixed(1)+'%';
  return `<div class="w-full h-2 rounded bg-slate-800/80 overflow-hidden" title="${esc(title)}">
    <div class="bar h-2 rounded bg-gradient-to-r from-amber-400 to-amber-200" style="width:${w}"></div>
  </div>`;
}

/* reveal */
const io = new IntersectionObserver(entries=>{
  entries.forEach(e=>{
    if(e.isIntersecting){
      e.target.classList.add('show','pulse-once'); io.unobserve(e.target);
      e.target.querySelectorAll('[data-count-to]').forEach(n=>animateCount(n, Number(n.dataset.countTo||0), n.dataset.suffix||''));
      e.target.querySelectorAll('.bar').forEach(b=>{ const w=b.style.width; b.style.width='0%'; requestAnimationFrame(()=>{ requestAnimationFrame(()=> b.style.width=w ); }); });
    }
  });
},{threshold:.2});
function mountReveal(scope){ (scope||document).querySelectorAll('.reveal').forEach(x=>io.observe(x)); }
function animateCount(el, toValue, suffix=''){
  if (!isFinite(toValue)) { el.textContent = 'â€”'; return; }
  const duration = 700, start = performance.now(); const from=0, to=Number(toValue);
  function step(t){ const k = Math.min(1,(t-start)/duration); const v = Math.round((from+(to-from)*k)*10)/10;
    el.textContent = suffix==='%'? (Math.round(v*10)/10)+suffix : v + suffix;
    if (k<1) requestAnimationFrame(step);
  } requestAnimationFrame(step);
}

/* Premium cosmetics */
const crownSVG = `<span title="Premium member" aria-label="Premium member">
  <svg class="inline-block ml-1 h-4 w-4 align-[-1px] text-amber-300" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
    <path d="M5 19h14a1 1 0 0 0 1-1v-7.5l-3.8 2.85a1 1 0 0 1-1.52-.47L12 5.6l-2.68 7.28a1 1 0 0 1-1.52.47L4 10.5V18a1 1 0 0 0 1 1Zm-3 2a1 1 0 1 0 0 2h20a1 1 0 1 0 0-2H2Z"/>
  </svg>
</span>`;
function labelWithPremium(steamId, display, isPrem){
  const base = esc(display || steamId || 'Player');
  return isPrem ? `<span class="text-amber-300" title="Premium member">${base}</span>${crownSVG}` : base;
}
async function isPremiumSteam(sid){
  try{
    const nowIso = new Date().toISOString();
    const { data } = await supa.from('profiles').select('steam_id').eq('steam_id', sid).gt('premium_until', nowIso).maybeSingle();
    return !!data;
  }catch{ return false; }
}
async function fetchPremiumSet(steamIds){
  const set = new Set(); if(!steamIds?.length) return set;
  try{
    const nowIso = new Date().toISOString();
    const { data } = await supa.from('profiles').select('steam_id').in('steam_id', steamIds).gt('premium_until', nowIso);
    (data||[]).forEach(r=> r.steam_id && set.add(String(r.steam_id)));
    return set;
  }catch{ return set; }
}

/* -------------------- Auth + Gate -------------------- */
async function getUser(){ const { data:{ user } } = await supa.auth.getUser(); return user||null; }
async function isPremium(user){
  try{ const { data } = await supa.from('profiles').select('premium_until').eq('id', user.id).maybeSingle();
    return !!(data?.premium_until && new Date(data.premium_until) > new Date());
  }catch{ return false; }
}
async function updateGateUI(){
  const gate = document.getElementById('gateBanner');
  const refreshBtn = document.getElementById('refreshBtn');
  const queueBtn   = document.getElementById('queueBtn');
  const cmpBtn     = document.getElementById('cmpBtn');
  const user = await getUser();
  if (!user) {
    gate.classList.remove('hidden');
    gate.innerHTML = `<div class="flex items-start gap-3">
      <div class="text-amber-300">ðŸ”’</div>
      <div>
        <div class="font-semibold mb-1">Sign in required</div>
        <div class="text-slate-300 text-sm">Perspective is a <b>Premium</b> feature. Please sign in with Discord to continue.</div>
        <div class="mt-2"><button id="signinBtn" class="px-3 py-1.5 rounded bg-indigo-600 hover:bg-indigo-500 text-white text-sm">Sign in with Discord</button></div>
      </div>
    </div>`;
    refreshBtn.disabled = true; queueBtn.disabled = true; cmpBtn.disabled = true;
    document.getElementById('signinBtn').onclick = ()=> supa.auth.signInWithOAuth({ provider:'discord', options:{ redirectTo: location.href }});
    return { user:null, premium:false };
  }
  const premium = await isPremium(user);
  if (!premium) {
    gate.classList.remove('hidden');
    gate.innerHTML = `<div class="flex items-start gap-3">
      <div class="text-amber-300">ðŸ‘‘</div>
      <div>
        <div class="font-semibold mb-1">Premium only</div>
        <div class="text-slate-300 text-sm">Perspective is available for <b>Premium members</b> only. Upgrade to unlock unlimited analyses and Perspective.</div>
        <div class="mt-2 flex items-center gap-2">
          <a href="account.html" class="px-3 py-1.5 rounded bg-amber-500/20 text-amber-300 border border-amber-500/30 hover:bg-amber-500/30 text-sm">Go Premium (â‚¬2)</a>
        </div>
      </div>
    </div>`;
    refreshBtn.disabled = true; queueBtn.disabled = true; cmpBtn.disabled = true;
    return { user, premium:false };
  }
  gate.classList.add('hidden');
  refreshBtn.disabled = false;
  queueBtn.disabled   = false;
  cmpBtn.disabled     = false;
  return { user, premium:true };
}

/* -------------------- Data fetch -------------------- */
async function fetchPlayer(){ const { data } = await supa.from('players').select('*').eq('steam_id', steamId).maybeSingle(); return data||null; }
async function fetchMatchesForPlayer(sid, limit=1200){
  const { data, error } = await supa.from('matches')
    .select('id, played_at, map_id, winner, p1_id, p2_id, p1_name, p2_name, p1_elo_before, p1_elo_after, p2_elo_before, p2_elo_after')
    .or(`p1_id.eq.${sid},p2_id.eq.${sid}`)
    .order('played_at', { ascending: true })
    .limit(limit);
  if (error) { console.warn('matches error', error); return []; }
  return data||[];
}
async function fetchAnalysesForMatchIds(ids){
  if (!ids.length) return new Map();
  const { data, error } = await supa.from('match_analyses')
    .select('match_id, p1_quality, p2_quality, p1_stats, p2_stats, analyzed_at')
    .in('match_id', ids);
  if (error) { console.warn('analyses error', error); return new Map(); }
  const map = new Map(); (data||[]).forEach(r=> map.set(r.match_id, r)); return map;
}

/* -------------------- Aggregation -------------------- */
function groupSessions(sortedMatches, gapMs=5*60*1000){
  const sessions = []; let cur=[]; let last=null;
  for (const m of sortedMatches){
    const t = new Date(m.played_at).getTime();
    if (last!=null && t - last > gapMs){ if (cur.length) sessions.push(cur); cur=[]; }
    cur.push(m); last=t;
  }
  if (cur.length) sessions.push(cur);
  return sessions;
}
function hourlyBuckets(matches, sid){
  // Local timezone (browser) buckets 0..23
  const buckets = Array.from({length:24}, ()=>({matches:0,wins:0}));
  for (const m of matches){
    const side = String(m.p1_id)===String(sid)?'p1':'p2';
    const win  = (m.winner===1||m.winner==='1') ? (side==='p1') : (m.winner===2||m.winner==='2') ? (side==='p2') : null;
    const h = new Date(m.played_at).getHours();
    buckets[h].matches++; if (win) buckets[h].wins++;
  }
  return buckets.map((b,i)=>({hour:i, matches:b.matches, winrate: b.matches? b.wins/b.matches : null}));
}

function aggregateMetrics(sid, matches, analyses, mapId=null, eloBandSet=null){
  // Filter by map
  let scope = mapId ? matches.filter(m=> String(m.map_id)===String(mapId)) : matches.slice();

  // Elo-band filter (bands are ints like 1000, 1100â€¦ representing [band .. band+99])
  if (eloBandSet && eloBandSet.size){
    scope = scope.filter(m=>{
      const side = (String(m.p1_id)===String(sid)) ? 'p1' : 'p2';
      const oppElo = side==='p1'
        ? (m.p2_elo_before ?? m.p2_elo_after ?? null)
        : (m.p1_elo_before ?? m.p1_elo_after ?? null);
      if (!Number.isFinite(oppElo)) return false;
      const band = Math.floor(Number(oppElo)/100)*100;
      return eloBandSet.has(band);
    });
  }

  const eloSeries = [], results = [];
  const qual=[], speeds=[], distH=[], distT=[];
  const tagShareRaw=[], tagShareFromSecs=[], tagSecs=[], hidSecs=[];
  const retMed=[], retAvg=[], acc=[];
  const byMap = new Map(), byOpp = new Map();

  for (const m of scope){
    const side = (String(m.p1_id)===String(sid)) ? 'p1' : 'p2';
    const oppId = (side==='p1') ? m.p2_id : m.p1_id;
    const oppName = (side==='p1') ? (m.p2_name||m.p2_id) : (m.p1_name||m.p1_id);

    const win = (m.winner===1 || m.winner==='1') ? (side==='p1') : (m.winner===2 || m.winner==='2') ? (side==='p2') : null;
    if (win!=null) results.push(!!win);

    const elo = (side==='p1') ? (m.p1_elo_after ?? m.p1_elo_before) : (m.p2_elo_after ?? m.p2_elo_before);
    if (elo!=null) eloSeries.push(Number(elo));

    const a = analyses.get(m.id);
    if (a){
      const q = (side==='p1') ? a.p1_quality : a.p2_quality;
      if (isFinite(q)) qual.push(Number(q));
      const s = (side==='p1') ? (a.p1_stats||{}) : (a.p2_stats||{});
      if (isFinite(s.avg_speed_ms)) speeds.push(Number(s.avg_speed_ms));
      if (isFinite(s.avg_distance_as_hider))  distH.push(Number(s.avg_distance_as_hider));
      if (isFinite(s.avg_distance_as_tagger)) distT.push(Number(s.avg_distance_as_tagger));

      if (isFinite(s.time_as_tagger_share)) tagShareRaw.push(Number(s.time_as_tagger_share));
      if (isFinite(s.seconds_as_tagger))    tagSecs.push(Number(s.seconds_as_tagger));
      if (isFinite(s.seconds_as_hider))     hidSecs.push(Number(s.seconds_as_hider));
      if (isFinite(s.seconds_as_tagger) && isFinite(s.seconds_as_hider)) {
        const total = Number(s.seconds_as_tagger)+Number(s.seconds_as_hider);
        if (total>0) tagShareFromSecs.push(Number(s.seconds_as_tagger)/total);
      }
      if (isFinite(s.retag_median_seconds)) retMed.push(Number(s.retag_median_seconds));
      if (isFinite(s.retag_avg_seconds))    retAvg.push(Number(s.retag_avg_seconds));
      if (isFinite(s.accuracy))             acc.push(Number(s.accuracy));
    }

    const keyM = String(m.map_id);
    if (!byMap.has(keyM)) byMap.set(keyM, { map_id:m.map_id, matches:0, wins:0, q:[], sp:[], ts:[], rm:[], dh:[], dt:[] });
    const bm = byMap.get(keyM);
    bm.matches++; if (win) bm.wins++;
    if (a){
      const s = (side==='p1') ? (a.p1_stats||{}) : (a.p2_stats||{});
      const q2 = (side==='p1') ? a.p1_quality : a.p2_quality;
      if (isFinite(q2)) bm.q.push(Number(q2));
      if (isFinite(s.avg_speed_ms)) bm.sp.push(Number(s.avg_speed_ms));
      let shareHere = null;
      if (isFinite(s.seconds_as_tagger) && isFinite(s.seconds_as_hider)) {
        const t = Number(s.seconds_as_tagger)+Number(s.seconds_as_hider);
        if (t>0) shareHere = Number(s.seconds_as_tagger)/t;
      } else if (isFinite(s.time_as_tagger_share)) {
        shareHere = Number(s.time_as_tagger_share);
      }
      if (shareHere!=null) bm.ts.push(shareHere);
      if (isFinite(s.retag_median_seconds)) bm.rm.push(Number(s.retag_median_seconds));
      if (isFinite(s.avg_distance_as_hider)) bm.dh.push(Number(s.avg_distance_as_hider));
      if (isFinite(s.avg_distance_as_tagger)) bm.dt.push(Number(s.avg_distance_as_tagger));
    }

    const ok = String(oppId||'unknown');
    if (!byOpp.has(ok)) byOpp.set(ok, { id:oppId, name:oppName, matches:0, wins:0, q:[] });
    const bo = byOpp.get(ok);
    bo.matches++; if (win) bo.wins++;
    if (a){
      const q2 = (side==='p1') ? a.p1_quality : a.p2_quality;
      if (isFinite(q2)) bo.q.push(Number(q2));
    }
  }

  const count = scope.length;
  const wins = results.filter(Boolean).length;
  const winrate = count ? wins / count : null;

  const share_as_tagger = (tagShareFromSecs.length ? avg(tagShareFromSecs) :
                           tagShareRaw.length ? avg(tagShareRaw) : null);

  const quality = {
    average: avg(qual), median: median(qual),
    lower_quartile: quantile(qual,.25), upper_quartile: quantile(qual,.75),
    best_match: qual.length? Math.max(...qual):null, worst_match: qual.length? Math.min(...qual):null,
    spread_std: std(qual),
    // simpler description: "middle 50% spread"
    spread_iqr: (quantile(qual,.75)!=null && quantile(qual,.25)!=null) ? (quantile(qual,.75)-quantile(qual,.25)) : null
  };

  const tagging = {
    share_as_tagger,
    time_as_tagger_average: avg(tagSecs),
    time_as_tagger_median: median(tagSecs),
    time_as_hider_average: avg(hidSecs),
    time_as_hider_median: median(hidSecs)
  };

  const speed = { average_mps: avg(speeds), p90_mps: p90(speeds), p10_mps: p10(speeds) };
  const distance = { average_hider_m: avg(distH), average_tagger_m: avg(distT) };
  const retag = { median_seconds: median(retMed), average_seconds: avg(retAvg), p90_seconds: p90(retMed) };
  const accuracy = { average: avg(acc) };

  const eloSeriesAll = eloSeries.slice();
  const form = lastN(results, 20);
  let bestStreak=0, cur=0; for(const r of results){ cur = r? cur+1 : 0; bestStreak = Math.max(bestStreak, cur); }

  const mapsArr = Array.from(byMap.values()).map(b=>({
    map_id: b.map_id,
    matches: b.matches,
    winrate: b.matches? b.wins/b.matches : null,
    average_quality: avg(b.q),
    average_speed_mps: avg(b.sp),
    share_as_tagger: avg(b.ts),
    retag_median_seconds: avg(b.rm),
    average_hider_distance_m: avg(b.dh),
    average_tagger_distance_m: avg(b.dt)
  })).sort((a,b)=> (b.matches - a.matches));

  const oppArr = Array.from(byOpp.values()).map(o=>({
    id:o.id, name:o.name, matches:o.matches,
    winrate:o.matches? o.wins/o.matches:null, average_quality: avg(o.q)
  })).sort((a,b)=> (b.matches - a.matches));

  // Sessions & time-of-day
  const sessions = groupSessions(scope);
  const sessionStats = {
    sessions: sessions.length,
    avg_matches_per_session: sessions.length? (sessions.map(s=>s.length).reduce((a,b)=>a+b,0)/sessions.length) : null,
    best_wr: sessions.length? Math.max(...sessions.map(s=>{
      const r = s.map(m=>{
        const side = String(m.p1_id)===String(sid)?'p1':'p2';
        const win  = (m.winner===1||m.winner==='1') ? (side==='p1') : (m.winner===2||m.winner==='2') ? (side==='p2') : null;
        return win===true;
      });
      return r.length? (r.filter(Boolean).length/r.length):0;
    })) : null,
    worst_wr: sessions.length? Math.min(...sessions.map(s=>{
      const r = s.map(m=>{
        const side = String(m.p1_id)===String(sid)?'p1':'p2';
        const win  = (m.winner===1||m.winner==='1') ? (side==='p1') : (m.winner===2||m.winner==='2') ? (side==='p2') : null;
        return win===true;
      });
      return r.length? (r.filter(Boolean).length/r.length):null;
    }).filter(x=>x!=null)) : null
  };
  const hourly = hourlyBuckets(scope, sid);

  return {
    scopeCount: count, wins, winrate, quality, tagging, speed, distance, retag, accuracy,
    eloSeries: eloSeriesAll, form, bestStreak, maps: mapsArr, opponents: oppArr,
    sessionStats, hourly
  };
}

/* -------------------- UI builders -------------------- */
function chip(label, value, tip, suffix=''){
  const show = (value==null||value==='â€”') ? 'â€”' : '';
  const dv = (value==null||value==='â€”') ? '' : `data-count-to="${value}" data-suffix="${suffix}"`;
  return `<div class="px-3 py-2 rounded-xl bg-slate-800/70 border border-slate-700 text-sm reveal">
    <span class="tip text-slate-400" data-tip="${esc(tip)}">${label}</span>
    <span class="ml-1 text-slate-100 font-semibold" ${dv}>${show||value}${suffix}</span>
  </div>`;
}
function section(title, body){
  return `<div class="mt-6 card reveal"><h3 class="text-xl font-semibold mb-3">${title}</h3>${body}</div>`;
}
function overviewChips(m){
  return [
    chip('Matches played', m.scopeCount||0, 'Number of matches included in the current scope (All, or the selected map/Elo filter).'),
    chip('Wins', m.wins||0, 'Number of wins in the current scope.'),
    chip('Win rate', m.winrate!=null? Math.round(m.winrate*1000)/10 : 'â€”', 'Percentage of matches won.', '%'),
    chip('Average quality', m.quality.average!=null? Number(m.quality.average).toFixed(1) : 'â€”', 'Average game quality score for this player.'),
    chip('Median quality', m.quality.median!=null? Number(m.quality.median).toFixed(1) : 'â€”', 'Middle value of the quality scores.'),
    chip('Quality IQR', (m.quality.spread_iqr!=null? Number(m.quality.spread_iqr).toFixed(1):'â€”'), 'Interquartile range (Q3âˆ’Q1): **middle 50% spread**. Smaller = more consistent.'),
    chip('Quality standard deviation', (m.quality.spread_std!=null? Number(m.quality.spread_std).toFixed(2):'â€”'), 'Overall spread of quality scores.'),
    chip('Best match quality', m.quality.best_match!=null? Number(m.quality.best_match).toFixed(1) : 'â€”', 'Highest quality score observed.'),
    chip('Worst match quality', m.quality.worst_match!=null? Number(m.quality.worst_match).toFixed(1) : 'â€”', 'Lowest quality score observed.'),
    chip('Tag time share', m.tagging.share_as_tagger!=null? Math.round(m.tagging.share_as_tagger*1000)/10 : 'â€”', 'Share of total time spent as the tagger.', '%'),
    chip('Average time as tagger', m.tagging.time_as_tagger_average!=null? Number(m.tagging.time_as_tagger_average).toFixed(1) : 'â€”', 'Seconds per match as tagger.', 's'),
    chip('Average time as hider', m.tagging.time_as_hider_average!=null? Number(m.tagging.time_as_hider_average).toFixed(1) : 'â€”', 'Seconds per match as hider.', 's'),
    chip('Average speed', m.speed.average_mps!=null? Number(m.speed.average_mps).toFixed(2) : 'â€”', 'Movement speed (m/s).', ' m/s'),
    chip('90th percentile speed', m.speed.p90_mps!=null? Number(m.speed.p90_mps).toFixed(2) : 'â€”', 'Top-burst speed (m/s).', ' m/s'),
    chip('Average hider distance', m.distance.average_hider_m!=null? Number(m.distance.average_hider_m).toFixed(2) : 'â€”', 'Distance as hider (m).', ' m'),
    chip('Average tagger distance', m.distance.average_tagger_m!=null? Number(m.distance.average_tagger_m).toFixed(2) : 'â€”', 'Distance as tagger (m).', ' m'),
    chip('Retag median', m.retag.median_seconds!=null? Number(m.retag.median_seconds).toFixed(1) : 'â€”', 'Typical time between tags.', 's'),
    chip('Retag average', m.retag.average_seconds!=null? Number(m.retag.average_seconds).toFixed(1) : 'â€”', 'Average time between tags.', 's'),
    chip('Retag p90', m.retag.p90_seconds!=null? Number(m.retag.p90_seconds).toFixed(1) : 'â€”', 'Slow retag (90th percentile).', 's'),
    chip('Accuracy (average)', m.accuracy.average!=null? Math.round(m.accuracy.average*1000)/10 : 'â€”', 'Share of successful attempts.', '%')
  ].join('');
}
function sectionForm(m){
  const dots = m.form.map(w => `<span class="w-3 h-3 rounded-full ${w?'bg-emerald-400':'bg-rose-400'} inline-block"></span>`).join('<span class="w-1 inline-block"></span>');
  return section('Form & rating',
    `<div class="flex items-center justify-between gap-4 flex-wrap">
      <div class="text-slate-300 tip" data-tip="Longest consecutive sequence of wins within the scope.">Best win streak: <b>${m.bestStreak||0}</b></div>
      <div class="flex items-center gap-1" title="Most recent results (green = win, red = loss).">${dots||'<span class="text-slate-500 text-sm">No recent games</span>'}</div>
      <div class="ml-auto" title="Rating trend over time.">${spark(m.eloSeries)}</div>
    </div>`);
}
function sectionTagging(m){
  return section('Tagging profile',
    `<div class="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Share of total time played as the tagger.">${pct(m.tagging.share_as_tagger)}</div>
        ${bar(m.tagging.share_as_tagger||0,'Tag time share')}
      </div>
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Average number of seconds spent as the tagger each match.">Average time as tagger</div>
        <div class="text-slate-100 font-semibold">${fmtS(m.tagging.time_as_tagger_average)} <span class="text-slate-400">Â· median ${fmtS(m.tagging.time_as_tagger_median)}</span></div>
      </div>
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Average number of seconds spent as the hider each match.">Average time as hider</div>
        <div class="text-slate-100 font-semibold">${fmtS(m.tagging.time_as_hider_average)} <span class="text-slate-400">Â· median ${fmtS(m.tagging.time_as_hider_median)}</span></div>
      </div>
    </div>`);
}
function sectionSpeedDistance(m){
  return section('Speed & distance',
    `<div class="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Average movement speed and 90th percentile (peak bursts).">Average speed / P90</div>
        <div class="text-slate-100 font-semibold">${num(m.speed.average_mps,2)} m/s Â· ${num(m.speed.p90_mps,2)} m/s</div>
      </div>
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Average distance traveled while playing as the hider.">Average hider distance</div>
        <div class="text-slate-100 font-semibold">${num(m.distance.average_hider_m,2)} m</div>
      </div>
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Average distance traveled while playing as the tagger.">Average tagger distance</div>
        <div class="text-slate-100 font-semibold">${num(m.distance.average_tagger_m,2)} m</div>
      </div>
    </div>`);
}
function sectionRetagAccuracy(m){
  return section('Retagging & accuracy',
    `<div class="grid grid-cols-1 md:grid-cols-3 gap-3">
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Typical time between consecutive tags.">Retag (median)</div>
        <div class="text-slate-100 font-semibold">${fmtS(m.retag.median_seconds)}</div>
      </div>
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Average and 90th percentile of retag time (lower is better).">Retag (average / P90)</div>
        <div class="text-slate-100 font-semibold">${fmtS(m.retag.average_seconds)} / ${fmtS(m.retag.p90_seconds)}</div>
      </div>
      <div>
        <div class="text-slate-300 tip mb-1" data-tip="Share of successful attempts; higher means better precision.">Accuracy (average)</div>
        <div class="text-slate-100 font-semibold">${m.accuracy.average!=null? pct(m.accuracy.average):'â€”'}</div>
      </div>
    </div>`);
}
function sectionQuality(m){
  return section('Quality & consistency',
    `<div class="grid grid-cols-1 md:grid-cols-4 gap-3">
      <div><div class="text-slate-300 tip mb-1" data-tip="Average game quality score.">Average quality</div><div class="text-slate-100 font-semibold">${num(m.quality.average,1)}</div></div>
      <div><div class="text-slate-300 tip mb-1" data-tip="Median game quality score.">Median quality</div><div class="text-slate-100 font-semibold">${num(m.quality.median,1)}</div></div>
      <div><div class="text-slate-300 tip mb-1" data-tip="Interquartile range (Q3âˆ’Q1). **Middle 50% spread**. Smaller = more consistent.">Quality IQR</div><div class="text-slate-100 font-semibold">${num(m.quality.spread_iqr,1)}</div></div>
      <div><div class="text-slate-300 tip mb-1" data-tip="Standard deviation of quality scores.">Quality SD</div><div class="text-slate-100 font-semibold">${num(m.quality.spread_std,2)}</div></div>
      <div class="md:col-span-2"><div class="text-slate-300 tip mb-1" data-tip="Average position inside the IQR band.">${num(m.quality.lower_quartile,1)} to ${num(m.quality.upper_quartile,1)} (IQR)</div>${bar(m.quality.average!=null && m.quality.upper_quartile!=null && m.quality.lower_quartile!=null ? ( (m.quality.average - m.quality.lower_quartile) / Math.max(0.001,(m.quality.upper_quartile - m.quality.lower_quartile)) ): 0, 'Average inside the IQR band')}</div>
      <div><div class="text-slate-300 tip mb-1" data-tip="Best single-match quality in scope.">Best match quality</div><div class="text-slate-100 font-semibold">${num(m.quality.best_match,1)}</div></div>
      <div><div class="text-slate-300 tip mb-1" data-tip="Worst single-match quality in scope.">Worst match quality</div><div class="text-slate-100 font-semibold">${num(m.quality.worst_match,1)}</div></div>
    </div>`);
}
function sectionMaps(maps, filter){
  if (filter != null) return '';
  if(!maps?.length) return section('Per-map breakdown','<div class="text-slate-400 text-sm">No data.</div>');
  const top = maps.slice(0, 12);
  const cards = top.map(mp=>`
    <div class="p-4 rounded-xl border border-slate-800 bg-slate-900/40">
      <div class="flex items-center justify-between">
        <div class="font-semibold">${prettyMap(mp.map_id)}</div>
      </div>
      <div class="mt-2 text-slate-400 text-sm">${mp.matches} matches</div>
      <div class="mt-3 grid grid-cols-2 gap-3 text-sm">
        <div><div class="text-slate-400">Win rate</div><div class="font-semibold">${mp.winrate!=null? Math.round(mp.winrate*1000)/10+'%':'â€”'}</div></div>
        <div><div class="text-slate-400">Avg quality</div><div class="font-semibold">${num(mp.average_quality,1)}</div></div>
        <div><div class="text-slate-400">Tag share</div><div class="font-semibold">${mp.share_as_tagger!=null? Math.round(mp.share_as_tagger*1000)/10+'%':'â€”'}</div></div>
        <div><div class="text-slate-400">Avg speed</div><div class="font-semibold">${num(mp.average_speed_mps,2)} m/s</div></div>
        <div class="col-span-2"><div class="text-slate-400">Retag median</div><div class="font-semibold">${fmtS(mp.retag_median_seconds)}</div></div>
      </div>
    </div>`).join('');
  return section('Per-map breakdown', `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${cards}</div>`);
}
function sectionOpponents(opps){
  if(!opps?.length) return section('Most faced opponents','<div class="text-slate-400 text-sm">No data.</div>');
  const rows = opps.slice(0,20).map(o=>{
    const wr = o.winrate!=null? Math.round(o.winrate*1000)/10 : null;
    return `<tr>
      <td class="py-2 pl-3">
        <a class="text-indigo-400 hover:underline" href="player.html?steam_id=${encodeURIComponent(o.id)}">${esc(o.name||o.id)}</a>
        <span class="text-slate-400"> Â· ${o.matches} matches</span>
      </td>
      <td class="py-2 pr-3 text-right">${wr==null?'â€”':wr+'%'} Â· avg quality ${num(o.average_quality,1)}</td>
    </tr>`;
  }).join('');
  return section('Most faced opponents',
    `<div class="overflow-x-auto rounded border border-slate-800">
      <table class="min-w-full text-sm"><tbody class="divide-y divide-slate-800">${rows}</tbody></table>
    </div>`);
}
function sectionSessionsAndTime(m){
  const hourBars = m.hourly.map(h=>{
    const v = h.winrate==null ? 0 : h.winrate;
    const height = Math.round(clamp01(v)*64); // 0..64px
    const label = h.winrate==null ? 'â€”' : `${Math.round(v*100)}%`;
    return `<div class="flex flex-col items-center gap-1">
      <div class="w-4 bg-amber-400/80 rounded" style="height:${height}px"></div>
      <div class="text-[10px] text-slate-400">${h.hour}</div>
      <div class="text-[10px] text-slate-500">${h.matches||0}</div>
    </div>`;
  }).join('');
  return section('Playtime & sessions',
    `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">
      <div>
        <div class="text-slate-400">Sessions (â‰¤5 min gap)</div>
        <div class="text-lg font-semibold">${m.sessionStats.sessions||0}</div>
        <div class="mt-2 text-slate-400">Avg matches per session</div>
        <div class="font-semibold">${num(m.sessionStats.avg_matches_per_session,2)}</div>
      </div>
      <div>
        <div class="text-slate-400">Best session win rate</div>
        <div class="text-lg font-semibold">${m.sessionStats.best_wr!=null? Math.round(m.sessionStats.best_wr*100):'â€”'}%</div>
        <div class="mt-2 text-slate-400">Worst session win rate</div>
        <div class="font-semibold">${m.sessionStats.worst_wr!=null? Math.round(m.sessionStats.worst_wr*100):'â€”'}%</div>
      </div>
      <div class="md:col-span-1">
        <div class="text-slate-400 mb-1">Win rate by hour (your timezone)</div>
        <div class="h-24 flex items-end gap-1">${hourBars}</div>
      </div>
    </div>`);
}
function renderAll(contentEl, metrics){
  contentEl.innerHTML = `
    <div id="chipGrid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3">
      ${overviewChips(metrics)}
    </div>
    ${sectionForm(metrics)}
    ${sectionTagging(metrics)}
    ${sectionSpeedDistance(metrics)}
    ${sectionRetagAccuracy(metrics)}
    ${sectionQuality(metrics)}
    ${sectionSessionsAndTime(metrics)}
    ${sectionMaps(metrics.maps, currentMapFilter)}
    ${sectionOpponents(metrics.opponents)}
  `;
  mountReveal(contentEl);
}

/* -------------------- Legacy worker summary -------------------- */
async function loadPerspectiveRow(pid){
  const { data } = await supa.from('player_perspectives')
    .select('*')
    .eq('player_id', pid)
    .eq('window_size', WINDOW_ALL)
    .maybeSingle();
  return data || null;
}
function renderLegacySummary(container, perspectiveRow){
  if (!perspectiveRow) { container.innerHTML = ''; return; }
  const s = perspectiveRow.summary || {};
  container.innerHTML = `
    <div class="mt-6 card">
      <div class="text-sm text-slate-300 mb-2">Worker summary</div>
      <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-3">
        <div><div class="text-slate-400">Matches</div><div class="font-semibold">${s.matches ?? 'â€”'}</div></div>
        <div><div class="text-slate-400">Wins</div><div class="font-semibold">${s.wins ?? 'â€”'}</div></div>
        <div><div class="text-slate-400">Win rate</div><div class="font-semibold">${s.winrate!=null? Math.round(s.winrate*1000)/10+'%':'â€”'}</div></div>
        <div><div class="text-slate-400">Avg quality</div><div class="font-semibold">${s.avg_quality!=null? Number(s.avg_quality).toFixed(1):'â€”'}</div></div>
        <div><div class="text-slate-400">Median quality</div><div class="font-semibold">${s.med_quality!=null? Number(s.med_quality).toFixed(1):'â€”'}</div></div>
        <div><div class="text-slate-400">Avg duration</div><div class="font-semibold">${s.avg_duration!=null? Number(s.avg_duration).toFixed(1)+'s':'â€”'}</div></div>
      </div>
    </div>`;
}

/* -------------------- JOB FLOW (old way) -------------------- */
let jobChannel = null;
function subscribePerspectiveRealtime(pid, onReady){
  if (jobChannel) { try{ supa.removeChannel(jobChannel); }catch{} jobChannel=null; }
  jobChannel = supa
    .channel('persp_live_'+pid)
    .on('postgres_changes',{ event:'INSERT', schema:'public', table:'player_perspectives', filter:`player_id=eq.${pid}` }, payload => onReady(payload.new))
    .on('postgres_changes',{ event:'UPDATE', schema:'public', table:'player_perspectives', filter:`player_id=eq.${pid}` }, payload => onReady(payload.new))
    .subscribe();
}
async function queuePerspectiveOld(pid, requestedBy){
  const { error } = await supa.from('perspective_requests')
    .insert({ player_id: pid, window_size: WINDOW_ALL, requested_by: requestedBy || 'web' });
  if (error) throw new Error(error.message || 'Insert failed');
}
async function waitPerspective(pid, timeoutMs=90000){
  const t0 = Date.now();
  while (Date.now() - t0 < timeoutMs) {
    const row = await loadPerspectiveRow(pid);
    if (row) return row;
    await new Promise(r => setTimeout(r, 1500));
  }
  return null;
}

/* -------------------- Filters (map + Elo) -------------------- */
let matchesCache=[], analysesCache=new Map();
let currentMapFilter=null;   // null = All maps
let currentEloBands=new Set; // empty = no band filter

function makePill(active, label, dataAttr, value){
  return `<button ${dataAttr}="${value}" class="px-3 py-1.5 pill ${active?'pill-active':''}">${label}</button>`;
}
function renderScopeBar(){
  const scopeBar = document.getElementById('scopeBar');
  const presentMaps = [...new Set(matchesCache.map(m=>m.map_id))].sort((a,b)=>a-b);
  scopeBar.innerHTML = `
    <div class="flex flex-wrap items-center gap-2">
      ${makePill(currentMapFilter==null, 'All', 'data-map', '')}
      ${presentMaps.map(mid=> makePill(currentMapFilter!=null && String(currentMapFilter)===String(mid), prettyMap(mid), 'data-map', mid)).join('')}
    </div>`;
  scopeBar.classList.remove('hidden');
  scopeBar.querySelectorAll('[data-map]').forEach(b=>{
    b.onclick = async ()=>{
      const v = b.getAttribute('data-map');
      currentMapFilter = v===''? null : v;
      await recomputeAndRender();
      renderScopeBar(); // refresh active
    };
  });
}

const ELO_BANDS = [800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800];
function inferAutoBand(){
  const series = matchesCache.map(m=>{
    const side = String(m.p1_id)===String(steamId)?'p1':'p2';
    const selfAfter = side==='p1'? (m.p1_elo_after ?? m.p1_elo_before) : (m.p2_elo_after ?? m.p2_elo_before);
    return Number(selfAfter);
  }).filter(Number.isFinite);
  if (!series.length) return 1300;
  const med = median(series);
  return Math.floor(med/100)*100;
}
function renderFilterBar(){
  const filterBar = document.getElementById('filterBar');
  const auto = inferAutoBand();
  const chips = ELO_BANDS.map(b=>{
    const active = currentEloBands.has(b);
    return `<button data-band="${b}" class="px-2 py-1 text-sm pill ${active?'pill-active':''}">${b}â€“${b+99}</button>`;
  }).join('');
  filterBar.innerHTML = `
    <div class="flex items-center gap-2 flex-wrap">
      <span class="text-slate-400 mr-1">Elo bands:</span>
      <button id="autoBand" class="px-2 py-1 text-sm pill">${auto}â€“${auto+99} (auto)</button>
      <button id="clearBands" class="px-2 py-1 text-sm pill">All opponents</button>
      ${chips}
    </div>`;
  filterBar.classList.remove('hidden');

  document.getElementById('autoBand').onclick = async ()=>{
    currentEloBands = new Set([inferAutoBand()]);
    await recomputeAndRender(); renderFilterBar();
  };
  document.getElementById('clearBands').onclick = async ()=>{
    currentEloBands = new Set(); await recomputeAndRender(); renderFilterBar();
  };
  filterBar.querySelectorAll('[data-band]').forEach(b=>{
    b.onclick = async ()=>{
      const band = Number(b.getAttribute('data-band'));
      if (currentEloBands.has(band)) currentEloBands.delete(band); else currentEloBands.add(band);
      await recomputeAndRender(); renderFilterBar();
    };
  });
}

/* -------------------- INIT & recompute -------------------- */
async function buildMetrics(){
  return aggregateMetrics(steamId, matchesCache, analysesCache, currentMapFilter, currentEloBands);
}
async function recomputeAndRender(){
  const content = document.getElementById('content');
  const status = document.getElementById('status');
  status.textContent = 'Computingâ€¦';
  const m = await buildMetrics();
  content.innerHTML = ''; renderAll(content, m);
  status.textContent = '';
}

async function init(){
  const head = document.getElementById('head');
  const status = document.getElementById('status');
  const jobInfo = document.getElementById('jobInfo');
  const content = document.getElementById('content');

  const player = await fetchPlayer();
  if(!player){ head.innerHTML='<div class="text-red-400">Player not found.</div>'; return; }
  const isPremSelf = await isPremiumSteam(steamId);
  head.innerHTML = `
    <div class="card reveal">
      <div class="flex items-center gap-4">
        <div class="w-14 h-14 rounded-full bg-indigo-600/20 border border-indigo-500/30 grid place-items-center text-xl font-bold text-indigo-300">
          ${(player.username||player.steam_id||'?').trim().charAt(0).toUpperCase()}
        </div>
        <div>
          <div class="text-2xl font-extrabold leading-tight">
            ${labelWithPremium(steamId, player.username||steamId, isPremSelf)}
          </div>
          <div id="chips" class="mt-2 grid grid-cols-2 sm:flex sm:flex-wrap gap-2"></div>
        </div>
      </div>
    </div>`;
  mountReveal(head);

  let gate = await updateGateUI();
  supa.auth.onAuthStateChange(async () => { gate = await updateGateUI(); });

  if (gate.premium){
    status.textContent = 'Loadingâ€¦';
    matchesCache = await fetchMatchesForPlayer(steamId, 1200);
    analysesCache = await fetchAnalysesForMatchIds(matchesCache.map(m=>m.id));
    renderScopeBar();
    renderFilterBar();
    await recomputeAndRender();

    // If worker row already exists, show summary
    const legacyRow = await loadPerspectiveRow(steamId);
    const legacyBox = document.createElement('div');
    content.prepend(legacyBox);
    renderLegacySummary(legacyBox, legacyRow);
  } else {
    content.innerHTML = `<div class="mt-6 text-slate-400">Sign in and go Premium to see Perspective.</div>`;
  }

  // Buttons
  document.getElementById('refreshBtn').onclick = async ()=>{
    if (!gate.user || !gate.premium) return;
    matchesCache = await fetchMatchesForPlayer(steamId, 1200);
    analysesCache = await fetchAnalysesForMatchIds(matchesCache.map(m=>m.id));
    renderScopeBar(); renderFilterBar();
    await recomputeAndRender();
  };

  document.getElementById('queueBtn').onclick = async ()=>{
    if (!gate.user || !gate.premium) return;
    try{
      jobInfo.textContent = 'Queuingâ€¦';
      subscribePerspectiveRealtime(steamId, async (row) => {
        jobInfo.textContent = 'Worker finished. Refreshingâ€¦';
        const legacyBox = document.createElement('div');
        document.getElementById('content').prepend(legacyBox);
        renderLegacySummary(legacyBox, row);
        document.getElementById('refreshBtn').click();
      });

      await queuePerspectiveOld(steamId, gate.user?.id || 'web');
      jobInfo.textContent = 'Queued. Waiting for workerâ€¦';

      const row = await waitPerspective(steamId, 90000);
      if (row){
        jobInfo.textContent = 'Ready âœ“';
        const legacyBox = document.createElement('div');
        document.getElementById('content').prepend(legacyBox);
        renderLegacySummary(legacyBox, row);
        document.getElementById('refreshBtn').click();
      } else {
        jobInfo.textContent = 'Still queued / timeout. It will appear here when ready.';
      }
    }catch(e){
      console.error(e);
      jobInfo.textContent = 'Failed to queue: ' + (e.message||e);
    }
  };

  // Compare (mirror) â€” render row by row so left/right stay aligned
  async function resolvePlayerSmart(text){
    if(!text) return null;
    if(/^\d{5,}$/.test(text)) return text;
    try{
      const rp = await supa.rpc('search_players',{ q:text, p_limit:1 });
      if (!rp.error && rp.data && rp.data.length) return rp.data[0].steam_id;
    }catch{}
    try{
      const { data } = await supa.from('players').select('steam_id, username').ilike('username', `%${text}%`).limit(1).maybeSingle();
      if (data?.steam_id) return data.steam_id;
    }catch{}
    return null;
  }

  document.getElementById('cmpBtn').onclick = async ()=>{
    if (!gate.user || !gate.premium) return;
    const cmpStatus = document.getElementById('cmpStatus');
    cmpStatus.textContent = '';
    const query = document.getElementById('cmpInput').value.trim();
    const applyFilter = document.getElementById('cmpUseFilter').checked;
    const other = await resolvePlayerSmart(query);
    if(!other){ cmpStatus.textContent='Player not found.'; return; }

    // Build both sides with identical filters to keep symmetry
    const A = aggregateMetrics(steamId, matchesCache, analysesCache, applyFilter? currentMapFilter : null, applyFilter? currentEloBands : new Set());
    const mB = await fetchMatchesForPlayer(other, 1200);
    const aB = await fetchAnalysesForMatchIds(mB.map(m=>m.id));
    const B = aggregateMetrics(other, mB, aB, applyFilter? currentMapFilter : null, applyFilter? currentEloBands : new Set());
    cmpStatus.textContent='';

    const premSet = await fetchPremiumSet([steamId, other]);
    const { data: pb } = await supa.from('players').select('username').eq('steam_id', other).maybeSingle();
    const nameB = (pb?.username || other);
    const nameA = (player.username || steamId);

    // Mirror summary header
    const wrap = document.createElement('div');
    wrap.innerHTML = `
      <div class="mirror-row">
        <div class="card text-right reveal">
          <div class="text-lg font-semibold">${labelWithPremium(steamId, nameA, premSet.has(String(steamId)))}</div>
          <div class="text-slate-300">Win rate <b>${A.winrate!=null? Math.round(A.winrate*1000)/10+'%':'â€”'}</b></div>
          <div class="text-slate-300 mt-1">Average quality <b>${num(A.quality.average,1)}</b></div>
          <div class="text-slate-300 mt-1">Average speed <b>${num(A.speed.average_mps,2)} m/s</b></div>
        </div>
        <div class="card reveal">
          <div class="text-lg font-semibold">${labelWithPremium(other, nameB, premSet.has(String(other)))}</div>
          <div class="text-slate-300">Win rate <b>${B.winrate!=null? Math.round(B.winrate*1000)/10+'%':'â€”'}</b></div>
          <div class="text-slate-300 mt-1">Average quality <b>${num(B.quality.average,1)}</b></div>
          <div class="text-slate-300 mt-1">Average speed <b>${num(B.speed.average_mps,2)} m/s</b></div>
        </div>
      </div>`;
    const rows = document.createElement('div');

    // Build sections row-by-row for alignment
    function rowPair(leftHTML, rightHTML){
      const row = document.createElement('div'); row.className='mirror-row';
      row.innerHTML = `<div>${leftHTML}</div><div>${rightHTML}</div>`;
      rows.appendChild(row);
    }
    // Chips
    rowPair(`<div class="card">${overviewChips(A)}</div>`, `<div class="card">${overviewChips(B)}</div>`);
    // Rest
    rowPair(sectionForm(A), sectionForm(B));
    rowPair(sectionTagging(A), sectionTagging(B));
    rowPair(sectionSpeedDistance(A), sectionSpeedDistance(B));
    rowPair(sectionRetagAccuracy(A), sectionRetagAccuracy(B));
    rowPair(sectionQuality(A), sectionQuality(B));
    rowPair(sectionSessionsAndTime(A), sectionSessionsAndTime(B));

    const content = document.getElementById('content');
    content.innerHTML = ''; content.appendChild(wrap); content.appendChild(rows);
    mountReveal(content);
  };
}
init();
</script>

<script src="auth.js"></script>
<script src="payments.js"></script>
</body>
</html>
